/*
 * Forge Framework - JS Binding Generator
 *
 * Emits a JavaScript module that wraps the compiled WASM component.
 *
 * Example output for component "Button":
 *
 *   // Button.forge.js  (auto-generated)
 *   let __wasm;
 *   async function __loadWasm() {
 *     const res  = await fetch(new URL('./Button.wasm', import.meta.url));
 *     const buf  = await res.arrayBuffer();
 *     const inst = await WebAssembly.instantiate(buf, ForgeRuntime.imports());
 *     __wasm = inst.instance.exports;
 *   }
 *   const __ready = __loadWasm();
 *
 *   export class Button extends ForgeComponent {
 *     static tag     = 'forge-button';
 *     static props   = ['label', 'color', 'onClick'];
 *     static wasmReady = __ready;
 *
 *     mount(el)   { __wasm.forge_mount_button(el.id, this._propsJson()); }
 *     update(el)  { __wasm.forge_update_button(el.id, this._propsJson()); }
 *     dispatch(el, ev) { __wasm.forge_dispatch_button(el.id, ev); }
 *     unmount(el) { __wasm.forge_unmount_button(el.id); }
 *   }
 *   customElements.define('forge-button', Button);
 */

#include "binding_gen.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

static void lower(char *dst, const char *src) {
    while (*src) { *dst++ = (char)tolower((unsigned char)*src++); }
    *dst = '\0';
}

static void kebab(char *dst, const char *src) {
    /* "MyButton" → "my-button" */
    int first = 1;
    while (*src) {
        char c = *src++;
        if (isupper((unsigned char)c) && !first) *dst++ = '-';
        *dst++ = (char)tolower((unsigned char)c);
        first = 0;
    }
    *dst = '\0';
}

static void emit_type_ts(const TypeRef *t, FILE *out) {
    if (!t) { fprintf(out, "any"); return; }
    switch (t->kind) {
    case TY_INT: case TY_LONG: case TY_SHORT: case TY_FLOAT: case TY_DOUBLE:
    case TY_UNSIGNED: fprintf(out, "number"); break;
    case TY_CHAR: fprintf(out, "string"); break;
    case TY_BOOL: fprintf(out, "boolean"); break;
    case TY_VOID: fprintf(out, "void"); break;
    case TY_PTR:
        if (t->inner && t->inner->kind == TY_CHAR)
            fprintf(out, "string");
        else
            fprintf(out, "number");
        break;
    case TY_FN_PTR: fprintf(out, "(...args: any[]) => any"); break;
    default: fprintf(out, "any"); break;
    }
}

int binding_gen_component(const ComponentNode *c, const BindingOptions *opts, FILE *out) {
    char lname[256], tag[256];
    lower(lname, c->name);
    kebab(tag,   c->name);

    int esm = !opts || opts->es_modules;
    int wc  = !opts || opts->web_component;

    /* ── File header ── */
    fprintf(out,
        "/**\n"
        " * AUTO-GENERATED by Forge Compiler\n"
        " * Component: %s\n"
        " * DO NOT EDIT — run `forge compile %s.cx` to regenerate\n"
        " */\n\n",
        c->name, c->name);

    if (esm) {
        fprintf(out, "import { ForgeRuntime, ForgeComponent } from './forge-runtime.js';\n\n");
    } else {
        fprintf(out, "(function(global) {\n");
        fprintf(out, "  const { ForgeRuntime, ForgeComponent } = global.Forge;\n\n");
    }

    /* ── WASM loader ── */
    fprintf(out, "let __wasm_%s = null;\n\n", lname);
    fprintf(out, "async function __load_%s() {\n", lname);
    fprintf(out, "  const url = new URL('./%s.wasm', import.meta.url);\n", c->name);
    fprintf(out, "  const res = await fetch(url);\n");
    fprintf(out, "  if (!res.ok) throw new Error(`[Forge] Failed to load %s.wasm: ${res.status}`);\n", c->name);
    fprintf(out, "  const buf  = await res.arrayBuffer();\n");
    fprintf(out, "  const env  = ForgeRuntime.wasmImports('%s');\n", lname);
    fprintf(out, "  const inst = await WebAssembly.instantiate(buf, { env });\n");
    fprintf(out, "  __wasm_%s = inst.instance.exports;\n", lname);
    fprintf(out, "  ForgeRuntime.registerExports('%s', __wasm_%s);\n", lname, lname);
    fprintf(out, "}\n\n");
    fprintf(out, "const __%s_ready = __load_%s();\n\n", lname, lname);

    /* ── Component class ── */
    fprintf(out, "class %s extends ForgeComponent {\n", c->name);
    fprintf(out, "  static tag      = 'forge-%s';\n", tag);
    fprintf(out, "  static wasmReady = __%s_ready;\n", lname);

    /* Prop names list */
    fprintf(out, "  static observedProps = [");
    for (int i = 0; i < c->prop_count; i++) {
        fprintf(out, "%s'%s'", i ? ", " : "", c->props[i].name);
    }
    fprintf(out, "];\n\n");

    /* mount */
    fprintf(out, "  mount(el) {\n");
    fprintf(out, "    const json = ForgeRuntime.serializeProps(this._props);\n");
    fprintf(out, "    __wasm_%s.forge_mount_%s(el.__forgeId, json.ptr, json.len);\n", lname, lname);
    fprintf(out, "  }\n\n");

    /* update */
    fprintf(out, "  update(el, newProps) {\n");
    fprintf(out, "    const json = ForgeRuntime.serializeProps(newProps);\n");
    fprintf(out, "    __wasm_%s.forge_update_%s(el.__forgeId, json.ptr, json.len);\n", lname, lname);
    fprintf(out, "  }\n\n");

    /* dispatch */
    fprintf(out, "  dispatch(el, event) {\n");
    fprintf(out, "    const ev = ForgeRuntime.serializeEvent(event);\n");
    fprintf(out, "    __wasm_%s.forge_dispatch_%s(el.__forgeId, ev.ptr);\n", lname, lname);
    fprintf(out, "  }\n\n");

    /* unmount */
    fprintf(out, "  unmount(el) {\n");
    fprintf(out, "    __wasm_%s.forge_unmount_%s(el.__forgeId);\n", lname, lname);
    fprintf(out, "  }\n");

    fprintf(out, "}\n\n");

    /* ── Web Component registration ── */
    if (wc) {
        fprintf(out, "if (!customElements.get('forge-%s')) {\n", tag);
        fprintf(out, "  customElements.define('forge-%s', %s);\n", tag, c->name);
        fprintf(out, "}\n\n");
    }

    if (esm) {
        fprintf(out, "export { %s };\n", c->name);
        fprintf(out, "export default %s;\n", c->name);
    } else {
        fprintf(out, "  global.Forge.components['%s'] = %s;\n", c->name, c->name);
        fprintf(out, "})(typeof globalThis !== 'undefined' ? globalThis : window);\n");
    }

    return 0;
}

/* ─── TypeScript Declaration File ─────────────────────────────────────────── */

int binding_gen_types(const ComponentNode *c, FILE *out) {
    char tag[256];
    kebab(tag, c->name);

    fprintf(out,
        "/**\n"
        " * AUTO-GENERATED TypeScript declarations for Forge component: %s\n"
        " */\n\n",
        c->name);

    /* Props interface */
    fprintf(out, "export interface %sProps {\n", c->name);
    for (int i = 0; i < c->prop_count; i++) {
        fprintf(out, "  %s: ", c->props[i].name);
        emit_type_ts(c->props[i].type, out);
        fprintf(out, ";\n");
    }
    fprintf(out, "}\n\n");

    /* State interface (internal, exported for testing) */
    fprintf(out, "export interface %sState {\n", c->name);
    for (int i = 0; i < c->state_count; i++) {
        fprintf(out, "  %s: ", c->state[i].name);
        emit_type_ts(c->state[i].type, out);
        fprintf(out, ";\n");
    }
    fprintf(out, "}\n\n");

    /* Component class declaration */
    fprintf(out, "export declare class %s extends HTMLElement {\n", c->name);
    for (int i = 0; i < c->prop_count; i++) {
        fprintf(out, "  %s: ", c->props[i].name);
        emit_type_ts(c->props[i].type, out);
        fprintf(out, ";\n");
    }
    fprintf(out, "  static readonly tag: 'forge-%s';\n", tag);
    fprintf(out, "  static wasmReady: Promise<void>;\n");
    fprintf(out, "}\n\n");

    /* JSX / TSX element type augmentation */
    fprintf(out,
        "declare global {\n"
        "  namespace JSX {\n"
        "    interface IntrinsicElements {\n"
        "      'forge-%s': Partial<%sProps> & { ref?: any };\n"
        "    }\n"
        "  }\n"
        "}\n",
        tag, c->name);

    return 0;
}
